\section{Unit Testing}

Unit tests were written alongside the code they were testing to ensure my code was robust and responded appropriately to all inputs. I aimed for a 70\% test coverage to ensure a significant amount of the application was tested. Table~\ref{tab:coverage} shows a breakdown of test coverage by package.

\begin{longtable}{p{.4\textwidth} p{0.15\textwidth} p{.2\textwidth}}
  \toprule
  \textbf{Package} & \textbf{Coverage} & \textbf{Tests Written}
  \\\midrule\midrule
  model/manager/hashtree
  & 75.2\%
  & 69
  \\
  model/manager/games
  & 61.3\%
  & 107
  \\
  model/manager/ignore
  & 90.6\%
  & 13
  \\
  model/net/tcp
  & 71.9\%
  & 27
  \\
  model/net/peer
  & 55.8\%
  & 111
  \\
  model/persistence/ethereum
  & 81.7\%
  & 20
  \\
  model/util
  & 61.2\%
  & 24
  \\\midrule\midrule
  \textbf{Total}
  & 71.1\%
  & 371
  \\\bottomrule\bottomrule
  \caption{Code coverage by package. Missing entries do not have code in them for example model/manager is only a wrapper for its child packages.}
  \label{tab:coverage}
\end{longtable}

\newparagraph
Automated tests were also written for the smart contract functions and tested locally using Ganache CLI~\cite{noauthor_trufflesuiteganache_2023}. 
Tests were not written for generic functions like getters and setts; this includes the Controller functions that were typically wrappers around Model functions. Equally, automated UI tests were omitted due to time constraints and that UI components were partially tested by the user walkthroughs.