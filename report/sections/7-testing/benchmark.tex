% chktex-file 44

\newpage
\section{Benchmarking}\label{sec:benchmark}

This project uses benchmarking to determine the overall performance and scalability of the application, whilst also being useful in discovering any bottlenecks or bugs.
Specifically, this section will test how varying the following conditions will effect the download speed of a game:

\begin{enumerate}
  \item how many peers we are connected to,
  \item how the data for the game is distributed in terms of file size and the number of files, and
  \item the block size that each file is broken up into.
\end{enumerate}

\vspace{2mm}\noindent
To ensure consistency in these results, we include the following constraints:

\begin{itemize}
  \item All benchmarks should be ran on the same hardware using the same OS,
  \item All tests should be ran three times,
  \item Test data should be pseudo-random, and
  \item All projects should aim for the target size of 40GB to match the average game size given in Section~\ref{subsec:design-data}.
\end{itemize}

\subsection*{Number of Peers}

This benchmark allows us to observe how the application scales when dealing with many peers at the same time and how if affects the overall performance of the application.
\x
For each run, we will create a project with 500 files, each of size 80MB and a shard size of 4MiB. We will then run $N$ peers locally to simulate a perfect network connection.

\begin{longtable}{l|llll|}
  \cline{2-5}\cline{2-5}\cline{2-5}\cline{2-5}\cline{2-5}
  & \multicolumn{4}{c|}{\hdr{Runtime (s)}}\\ \hline
  \multicolumn{1}{|l|}{\hdr{Peers}} 
  & \multicolumn{1}{l|}{\hdr{1}} 
  & \multicolumn{1}{l|}{\hdr{2}} 
  & \multicolumn{1}{l|}{\hdr{3}} & \hdr{avg.}  \\ \hline
  \multicolumn{1}{|l|}{1} & 
  \multicolumn{1}{l|}{56} & 
  \multicolumn{1}{l|}{65} & 
  \multicolumn{1}{l|}{63} &  
  61.3
  \\ \hline
  \multicolumn{1}{|l|}{2} & 
  \multicolumn{1}{l|}{65} & 
  \multicolumn{1}{l|}{64} & 
  \multicolumn{1}{l|}{60} &  
  63
  \\ \hline
  \multicolumn{1}{|l|}{4} & 
  \multicolumn{1}{l|}{66} & 
  \multicolumn{1}{l|}{65} & 
  \multicolumn{1}{l|}{65} &  
  65.7
  \\ \hline
  \multicolumn{1}{|l|}{8} & 
  \multicolumn{1}{l|}{66} & 
  \multicolumn{1}{l|}{62} & 
  \multicolumn{1}{l|}{60} &  
  62.7
  \\ \hline
  \caption{How varying the peer count affects download speed}
\end{longtable}

\noindent
These results show us that increasing the number of peers does not increase or decrease the download speed. However, some important notes about these results are:

\begin{itemize}
  \item Having more peers distributes the workload across the network. This reduces the load on individual peers, who can then share data with other users.
  \item In reality, peers may have variable or weak network connections so having more peers may be a much larger contributing factor to download speed. 
  \item There may be a bottleneck elsewhere in the application. For example, we may see better performance using UDP instead of TCP.
\end{itemize}

\subsection*{Game Size}

This benchmark will be useful in discovering an optimal strategy for determining the directory structure of games uploaded to the network to allow developers to optimise their uploads to give the greatest download speed. 
\x
For each run, we will create a project with $F$ files of size $S$MB, such that $F\times S = 40GB$, and a shard size of 4MiB. We will then run 1 peer locally to simulate a perfect network connection.

\begin{longtable}{rr|llll|}
  \hline
  \multicolumn{2}{|c|}{\hdr{File}}
  & \multicolumn{4}{c|}{\hdr{Runtime (s)}}
  \\\hline
  \multicolumn{1}{|l|}{\hdr{Count}} 
  & \hdr{Size (MB)}
  & \multicolumn{1}{l|}{\hdr{1}} 
  & \multicolumn{1}{l|}{\hdr{2}} 
  & \multicolumn{1}{l|}{\hdr{3}} 
  & \hdr{avg.}
  \\ \hline
  \multicolumn{1}{|r|}{200} 
  & 200
  & \multicolumn{1}{l|}{57} 
  & \multicolumn{1}{l|}{55} 
  & \multicolumn{1}{l|}{58} 
  &  57
  \\\hline
  \multicolumn{1}{|r|}{100} 
  & 400
  & \multicolumn{1}{l|}{56} 
  & \multicolumn{1}{l|}{52} 
  & \multicolumn{1}{l|}{58} 
  & 55
  \\\hline
  \multicolumn{1}{|r|}{50} 
  & 800
  & \multicolumn{1}{l|}{110} 
  & \multicolumn{1}{l|}{109} 
  & \multicolumn{1}{l|}{110} 
  & 110
  \\\hline
  \multicolumn{1}{|r|}{25} 
  & 1,600
  & \multicolumn{1}{l|}{110} 
  & \multicolumn{1}{l|}{108} 
  & \multicolumn{1}{l|}{114} 
  & 111
  \\\hline
  \multicolumn{1}{|r|}{5} 
  & 8,000
  & \multicolumn{1}{l|}{311} 
  & \multicolumn{1}{l|}{318} 
  & \multicolumn{1}{l|}{311} 
  & 313
  \\\hline
  \multicolumn{1}{|r|}{1} 
  & 40,000
  & \multicolumn{1}{l|}{1,548} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  &  
  \\\hline
  \caption{How varying file count and size affects download speed}
\end{longtable}

\noindent From these results, we can see that distributing data across a larger pool of files results in a greater download speed.
This occurred for several reasons:

\begin{enumerate}
  \item A file can only be written to by one process at one time so having less files will reduce the potential for parallelisation.
  \item For each block downloaded: we open a writer to a file, write a single block, and close the writer. This adds a lot of overhead for files that have many blocks.
\end{enumerate}

\vspace{2mm}\noindent
There are several optimisations we could make to improve this result:

\begin{enumerate}
  \item Using batch requests would increase the amount of data we would have to write to a file at once.
  \item Using a memory buffer before writing to disk to increase the chance that we are writing many blocks to the same file at once.
\end{enumerate}

\subsection*{Block Size}

This benchmark will be useful in determining an optimal block size to use that maximises download speed.
\x
For each run we will create a new project with 500 files, each of size 80MB, and a shard size of $B$MiB. We will then run 1 peer locally to simulate a perfect network connection.

\begin{longtable}{rr|llll|}
  \cline{3-6}\cline{3-6}\cline{3-6}\cline{3-6}\cline{3-6}
  && \multicolumn{4}{l|}{\hdr{Runtime (s)}}
  \\ \hline
  \multicolumn{1}{|l|}{\hdr{Block Size (MiB)}} 
  & \multicolumn{1}{|l|}{\hdr{Total Blocks}} 
  & \multicolumn{1}{l|}{\hdr{1}} 
  & \multicolumn{1}{l|}{\hdr{2}} 
  & \multicolumn{1}{l|}{\hdr{3}} 
  & \hdr{avg.}
  \\\hline
  \multicolumn{1}{|r|}{1} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & 
  \\\hline
  \multicolumn{1}{|r|}{2} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & 
  \\\hline
  \multicolumn{1}{|r|}{4} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & 
  \\\hline
  \multicolumn{1}{|r|}{8} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & 
  \\\hline
  \multicolumn{1}{|r|}{16} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & \multicolumn{1}{l|}{} 
  & 
  \\\hline
  \caption{How varying the shard size of the hash tree affects download speed}
\end{longtable}